---
title: 'Auxilliary analysis: Mean network'
author: "Mariella Gregorich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2:
    theme: cosmo
    number_sections: true
    keep_md: no
    fig_caption: true
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: 
      collapsed: true
      smooth_scroll: true
    highlight: tango
---

<style type="text/css">
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
  font-family: bold;
}
h2 { /* Header 2 */
  font-size: 22px;
  color: DarkBlue;
  font-family: bold;
}
h3 { /* Header 3 */
  font-size: 18px;
}
h1.title {
  font-size: 38px;  text-align: center;
    font-family: bold;
}
h3.subtitle { 
    font-size: 24px;
  color: Black;
  text-align: center;
}
h4.author { 
    font-size: 18px;
  color: Black;
  text-align: center;
}
h4.date {
  font-size: 18px;
  color: Black;
  text-align: center;
}

body{
  font-size: 12pt;
}
</style>

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = F, warning=F, message=F)
pacman::p_load(mvtnorm, igraph, NetworkToolbox, Rcpp, RcppEigen, MASS, lqmm, ggplot2, gridExtra,
               stringr, future.apply, parallel, dplyr, tidyr, knitr, reshape2,kableExtra,
               rmarkdown, bookdown, forcats, rmdformats)
source("../functions_aux.R")
source("../01_data_generation.R")

```

# Background

## Data-generating design
Individual-specific networks are currently constructed based on a $p\times p$-dimensional mean scale-free covariance matrix $\alpha_0$, where $p$ denotes the number of nodes.  altered by two individual-specific latent variables $(X_{1i},X_{2i})$. The mean covariance indicates the default connections between pairs of nodes and its entries $\alpha_0(r,s)\sim \beta(1,0.5) , r,s=1,...,p$.

Individual-specific covariance entries $\Omega_i$ are obtained by
$\Omega_i = \alpha_0(r,s) + \alpha_1(r,s)X_{1i} + \alpha_2(r,s)X_{2i}$, where $\alpha_1, \alpha_2$ are drawn from a standard normal distribution.
The partial correlation between node $s$ and $r$ defining the pairwise edge weight for individual $i$ is then constructed through the definition of partial correlation:
$\rho_i(s,r)=-\frac{\Omega_i(s,r)}{\sqrt(\Omega_i(s,s)\Omega_i(r,r))}$

## Parameter
```{r}
## ----------- Parameters -------------------------
set.seed(1234)

n=100
q=2; delta=1                                                                    # q: number of covariates; delta: variance of covariate xi; qstar: number of latent processes
p=25;  po=(p-1)*p/2                                                             # p: number of biomarker nodes;  po: number of undirected edges
sthresh = 0.2                                                                   # Sparsification threshold for data gen
thresh.seq = seq(0,1,0.025)                                                     # Sparsification sequence for data ana

## zeta: qxp matrix of weighting for mean 
zeta=matrix(0,q,p)
sweight=seq(-2.5,2.5,0.5)
zeta[,sample(1:p, round(p*0.6))] <- sample(sweight, round(p*0.6)*q, replace = T)

### alpha: weighting matrix for the covariates to define the precision matrix
alpha.distr=list("icpt"=c("par1"=1, "par2"=0.5), "weights"=c("par1"=0, "par2"=1)) 
alpha.strc <- as.matrix(as_adjacency_matrix(sample_pa(n=25, power=1, m=2)))
alpha.icpt <- alpha.strc[lower.tri(alpha.strc)]
alpha.icpt[alpha.icpt==1] <- rbeta(sum(alpha.icpt), alpha.distr$icpt[1], alpha.distr$icpt[2])
alpha.imat=matrix(alpha.icpt,1,po, byrow = T)

alpha.weights <- rep(alpha.strc[lower.tri(alpha.strc)],q)
alpha.weights[alpha.weights==1] <- rnorm(sum(alpha.weights), alpha.distr$weights[1], alpha.distr$weights[2])                              
alpha.wmat=matrix(alpha.weights,q,po, byrow = T)
alpha=list("icpt"=alpha.icpt, "wmat"=alpha.wmat)

### 1/sigma^2
obeta0=rep(1,p)   ### sigma0^2=0.1

## number of possible undirected edges
po=(p-1)*p/2

### 2nd stage parameter
beta0=10               # intercept
xbeta=2.5              # coefficients for covariate X
gbeta=2.5              # coefficients for network features fmi

sparams <- list(n=n, p=p, q=q, zeta=zeta, alpha=alpha, obeta0=obeta0, delta=delta, beta0=beta0, xbeta=xbeta, gbeta=gbeta, thresh=sthresh)

df.sparams <- data.frame("Terms"=c("Sample size", "Nodes",  "Possible edges","Latent processes","Diagonal entries of covariance"),
                         "Values"=c(n,p,po,q,obeta0[1]))
df.sparams  %>%
  kbl(caption="Parameters for the data-generating mechanism", escape = F) %>%
  kable_classic(full_width = T, html_font = "Calibri")%>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, position = "left",fixed_thead = T)
```


## Graph-theoretical features

```{r, echo=F, warning=F, message=F}
text_tbl <- data.frame(
  Variable = c("Clustering coefficient", "Characteristic path length", "Modularity", 
            "Assortativity","Radius", "Diameter", "Eigen-centrality"),
  Explanation = c("ex1", "ex2", "ex3"," ex4", "ex5", "ex6", "ex7")
)

kbl(text_tbl) %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>%
  column_spec(2, width = "30em")
```



# Mean Network

## Visualization
```{r, fig.show="hold", out.width="50%"}
xi=rep(0, q)
ox=alpha.icpt + c(xi%*%alpha.wmat)
ox=-ox
Omegai=VecToSymMatrix(obeta0, -ox)

count=0; sr=1
mii=numeric((p-1)*p/2); sr=1
for (s in 1:(p-1)) {
  for (r in (s+1):p) {
    # rho^2=pho
    pho=ox[sr]/sqrt(obeta0[s]*obeta0[r])
    if (abs(pho)>0.9999){count=count+1}
    pho=ifelse(abs(pho)>0.9999, sign(pho)*0.9999, pho)
    mii[sr]=pho
    sr=sr+1
  }
}

mnet=VecToSymMatrix(1, mii, p)

mnet.bin <- mnet
mnet.bin[abs(mnet.bin)>0]<-1

ig <- graph_from_adjacency_matrix(mnet.bin, mode="undirected", diag=F)
co <- layout_nicely(ig)
plot(ig, main="Visualization of the mean network")
```

## Edge weight distribution

```{r , fig.show="hold", out.width="50%", echo=F, warning=F, fig.width=10, fig.height=6, fig.align='center', fig.cap="Histogramm of the edge weight components (alpha1, alpha2) of mnet excluding zero entries"}
par(mar = c(4, 4, .1, .1))
hist(ox[ox!=0], main="", xlab="Distribution of the weights in the mean covariance matrix", breaks=20, 
     cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
hist(mii[mii!=0], main="", xlab="Distribution of the weights in the mean network", breaks=20,
     cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
```


## Network thresholding and graph-theoretical features
```{r, echo=F, warning=F, message=F}
# CC for threshold sequence
mnet = abs(mnet)

data.mnet <- evalIndivNetwork(mnet, msize=p, thresh.seq, toMatrix = F)

data.mnet %>%
  ggplot(.,aes(x=Thresh, y=value, col=variable)) +
  geom_line() +
  theme_bw() +
  scale_color_brewer("Graph features", palette = "Dark2") +
  theme(text=element_text(size=14)) +
  facet_wrap(~ThreshMethod)

```


# Individual-specific variation around the mean

```{r, echo=F, warning=F, message=F, fig.align='center', fig.width=8, fig.height=12, fig.caption="Individual-specific variability of graph-theoretical features for 100 individuals"}
data.graph <- genIndivNetwork(n=sparams$n, p=sparams$p, q=sparams$q, alpha=sparams$alpha, 
                                  obeta0=sparams$obeta0, delta)
data.graph$GE = abs(data.graph$GE)

# CC for threshold sequence
list.gvars <- lapply(1:nrow(data.graph$GE), function(x) data.frame("Subj"=x, 
                                                                   evalIndivNetwork(eweights=data.graph$GE[x,], msize=p, tseq=thresh.seq)))
data.gvars <- do.call(rbind,list.gvars)

data.gvars$Type <- "indiv"
data.mnet$Subj <- 0
data.mnet$Type <- "mean"


df <- data.frame(rbind(data.mnet, data.gvars)) %>%
   mutate(Type=fct_relevel(Type, c("mean", "indiv"))) %>%
   mutate(variable=fct_recode(variable, "CC (unweighted)"="cc.uw", "CC (weighted)"="cc.w", "Radius"="rad", 
                                          "Diameter"="dia", "CPL"="cpl", "Eigen-Centrality"="es",
                                          "Assortativity"="ass", "Modularity"="mod"))
gvars <- unique(df$variable)
```

## Weight-based thresholding



```{r, echo=F, warning=F, message=F, fig.align='center', fig.width=8, fig.height=12, fig.caption="Individual-specific variability of graph-theoretical features for 100 individuals"}
plot.list <- list()
for(i in 1:length(gvars)){
 plot.list[[i]] <- df %>%
    data.frame() %>%
    mutate_at(3:4, to_numeric) %>%
    mutate_at(c(1,2,5,6), as.factor) %>%
    filter(variable %in% gvars[i] & ThreshMethod %in% "weight-based") %>%
    ggplot(., aes(x = Thresh, y=value, group=Subj, col=Type)) +
      geom_line(alpha=0.5) +
      ggtitle(gvars[i]) +
      scale_color_manual(values=c("royalblue4","slategray2")) +
      theme_bw() +
      aes(group=rev(Subj)) +
      theme(text=element_text(size=12),legend.position="none")
}

grid.arrange(grobs = plot.list, ncol=2)
```


## Density-based thresholding
```{r, echo=F, warning=F, message=F, fig.align='center', fig.width=8, fig.height=12, fig.caption="Individual-specific variability of graph-theoretical features for 100 individuals"}
plot.list <- list()
for(i in 1:length(gvars)){
 plot.list[[i]] <- df %>%
    data.frame() %>%
    mutate_at(3:4, to_numeric) %>%
    mutate_at(c(1,2,5,6), as.factor) %>%
    filter(variable %in% gvars[i] & ThreshMethod %in% "density-based") %>%
    ggplot(., aes(x = Thresh, y=value, group=Subj, col=Type)) +
      geom_line(alpha=0.5) +
      ggtitle(gvars[i]) +
      scale_color_manual(values=c("royalblue4","slategray2")) +
      theme_bw() +
      aes(group=rev(Subj)) +
      theme(text=element_text(size=12),legend.position="none")
}

grid.arrange(grobs = plot.list, ncol=2)
```