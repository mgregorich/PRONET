---
title: 'Auxiliary analysis: Error estimation for noise(Y) and noise(G)'
author: "Mariella Gregorich"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2:
    css: "../src/css_style.css"
    theme: cosmo
    number_sections: true
    keep_md: no
    fig_caption: true
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: true
      smooth_scroll: true
    highlight: tango
bibliography: ..\\src\\references.bib 
---

```{r setup, include=FALSE}
rm(list=ls())
#knitr::opts_chunk$set(echo = F, warning=F, message=F)
set.seed(666)

source(here::here("src", "setup.R"))
source(here::here("src", "functions_main.R"))
source(here::here("src", "functions_aux.R"))

N = 150
P = 150
rps = 10
```



```{r}
compute_scnR2 <- function(scn){
  # scn = data.frame(scenarios.single[7,])
  sourceCpp(here::here("src","utils.cpp"))
  scn <- data.frame(scn)
  p = scn$p
  n = scn$n
  po = (scn$p-1)*scn$p/2  
  
  # Preprocess
  beta.params = unlist(scn$beta.params, use.names = F)
  alpha0.params = unlist(scn$alpha0.params, use.names = F)
  alpha12.params = unlist(scn$alpha12.params, use.names = F)
  Z1.params = unlist(scn$Z1.params, use.names = F)
  Z2.params = unlist(scn$Z2.params, use.names = F)
  dg.method = names(scn$dg.thresh)
  
  R2 <- rep(NA, rps)
  for(i in 1:rps){
    # -- Setup default network
    dnw.params <- genDefaultNetwork(scn$p, scn$q, beta.params, alpha0.params, alpha12.params, Z1.params, Z2.params)

    # Data generation
  
    data.gen <- generate_data(setting=scn$setting,
                                n = scn$n,
                                p = scn$p,
                                q = scn$q,
                                alpha = dnw.params$alpha,
                                mu = dnw.params$mu,
                                eta.params = dnw.params$eta.params,
                                beta.params = unlist(scn$beta.params),
                                Z1.params = unlist(scn$Z1.params),
                                Z2.params = unlist(scn$Z2.params),
                                b0 = scn$b0,
                                b1 = scn$b1,
                                b2=scn$b2,
                                eps.y = scn$eps.y,
                                eps.g = scn$eps.g,
                                dg.thresh = scn$dg.thresh,
                                dg.spars = scn$dg.spars,
                                step.size = scn$step.size)
    data.fun <- data.gen$fun
    data.graph <- data.gen$data
  
    # Estimation of the graph-theoretical features
  
    k=5
    data.network <- data.graph[,paste0("GE.noisy.",1:po)]
    data.graph$ID <- 1:n
    data.graph$fold <- cvFolds(length(unique(data.graph$ID)), K=k)$which
  
  
    # CC for threshold sequence
    data.gvars <- wrapperThresholding(df=data.network, msize=p, step.size = scn$step.size)
  
  # Add outcome Y
  data.gvars <- merge(data.graph[,c("ID","Y", "X", "fold")], data.gvars, by="ID") %>%
    mutate(Value=ifelse(is.nan(Value), NA, Value)) %>%
    mutate_at(vars(Thresh, Y, Value), as.numeric) %>%
    filter(Variable %in% "cc.uw") 
  
  
    # Estimation of the oracle model
    true.params = data.frame("ID"= 1:nrow(data.graph),
                             "DGMethod"=dg.method,
                             "DGThresh"=data.graph$dg.threshold,
                             "SparsMethod"="weight-based",
                             "ThreshMethod"="trim",
                             "Variable"="cc.uw")
        
  # --  Oracle model
  # Data preparation for oracle model
  if(dg.method %in% c("single","random")){
    data.oracle <- data.gvars %>%
      filter(SparsMethod == true.params$SparsMethod & ThreshMethod == true.params$ThreshMethod &
               Variable == true.params$Variable) %>%
      group_by(Thresh) %>%
      mutate("true.t"=data.graph$dg.threshold) %>%
      filter(Thresh == round(true.t,2)) %>%
      dplyr::select(!true.t)
  }else if(dg.method %in% c("flat", "half-sine", "sine")){
    mat.gvars <- data.gvars %>%
      filter(SparsMethod == true.params$SparsMethod & ThreshMethod == true.params$ThreshMethod &
               Variable == true.params$Variable) %>%
      dplyr::select(ID, Thresh, Value) %>%
      arrange(Thresh) %>%
      pivot_wider(names_from = "Thresh", values_from = "Value")
    
    prod.betaX.true <- rowSums(t(data.fun$betafn.true * t(mat.gvars[,-1])))
    
    data.oracle <- data.gvars %>%
      filter(SparsMethod == true.params$SparsMethod & ThreshMethod == true.params$ThreshMethod &
               Variable == true.params$Variable & Thresh == 0) %>%
      mutate(Value = prod.betaX.true*(b1/5))
  }
  oracle_adjust <- ifelse(scn$setting %in% "uni", FALSE, TRUE)
  data.oracle.res <- data.oracle %>%
    group_by(ThreshMethod, SparsMethod, Variable) %>%
    nest() %>%
    mutate(res=lapply(data, function(x) evalLM(df=x, k=k, adjust=oracle_adjust))) %>%
    unnest(res) %>%
    mutate("AnaMethod"="Oracle",
           Thresh=NA)
    
    R2[i] <- data.oracle.res$R2
  }
  return(mean(R2))
}
```

# Setting: uni

* Sample size n = `r N`
* Nodes p = `r P`
* Results averaged over 10 runs
* Previous value of Noise(Y)=[0, 0.5, 1]
* Previous values of Noise(G)=[0, 0.05, 0.1] (but now Noise(G) added to $\eta_i$, so not comparable)


## Scenario: single threshold = 0.25
```{r single}
# --- Scenario: single threshold = 0.25
scenarios$R2 <- NA
scenarios.single <- scenarios %>% filter(n==N & p==P & b1==10 & b2==10 & names(dg.thresh) == "single" & setting == "uni")
# scenarios.single$eps.y[scenarios.single$eps.y==1] <- 1.5
# scenarios.single$eps.y[scenarios.single$eps.y==2] <- 3
# scenarios.single$eps.g[scenarios.single$eps.g==1] <- 1
# scenarios.single$eps.g[scenarios.single$eps.g==2] <- 2
plan(multisession, workers=detectCores()*.75)
scenarios.single$R2 <- future_sapply(1:nrow(scenarios.single), function(x) compute_scnR2(data.frame(scenarios.single[x,])), future.seed=TRUE)
scenarios.single$R2 <- round(scenarios.single$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.single)
```

## Scenario: random threshold U(0.1,0.4)
```{r random}
# --- Scenario: random threshold U(0.1,0.4)
scenarios.random <- scenarios %>% filter(n==N & p==P & b1==10 & b2==10 & names(dg.thresh) == "random" & setting == "uni")
# scenarios.random$eps.y[scenarios.random$eps.y==2] <- 4
# scenarios.random$eps.y[scenarios.random$eps.y==1] <- 2
# scenarios.random$eps.g[scenarios.random$eps.g==2] <- 2
# scenarios.random$eps.g[scenarios.random$eps.g==1] <- 1
plan(multisession, workers=detectCores()*.6)
scenarios.random$R2 <- future_sapply(1:nrow(scenarios.random), function(x) compute_scnR2(data.frame(scenarios.random[x,])), future.seed=TRUE)
scenarios.random$R2 <- round(scenarios.random$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.random)

```

## Scenario: functional form = flat
```{r flat}
# --- Scenario: functional form
scenarios.func1 <- scenarios %>% filter(n==N & b1==10 & b2==10 & p==P & dg.thresh == "flat" & setting == "uni")
# scenarios.func1$eps.y[scenarios.func1$eps.y==1] <- 0.5
# scenarios.func1$eps.y[scenarios.func1$eps.y==2] <- 1
# scenarios.func1$eps.g[scenarios.func1$eps.g==1] <- 1
# scenarios.func1$eps.g[scenarios.func1$eps.g==2] <- 2
plan(multisession, workers=detectCores()*.75)
scenarios.func1$R2 <- future_sapply(1:nrow(scenarios.func1), function(x) compute_scnR2(data.frame(scenarios.func1[x,])), future.seed=TRUE)
scenarios.func1$R2 <- round(scenarios.func1$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func1)
```

## Scenario: functional form = half-sine

```{r halfsine}
# --- Scenario: functional form
scenarios.func2 <- scenarios %>% filter(n==N & b1==10 & b2==10 & p==P & dg.thresh == "half-sine" & setting == "uni")
# scenarios.func2$eps.y[scenarios.func2$eps.y==1] <- 1
# scenarios.func2$eps.y[scenarios.func2$eps.y==2] <- 2
# scenarios.func2$eps.g[scenarios.func2$eps.g==1] <- 1
# scenarios.func2$eps.g[scenarios.func2$eps.g==2] <- 2
plan(multisession, workers=detectCores()*.75)
scenarios.func2$R2 <- future_sapply(1:nrow(scenarios.func2), function(x) compute_scnR2(data.frame(scenarios.func2[x,])), future.seed=TRUE)
scenarios.func2$R2 <- round(scenarios.func2$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func2)
```


## Scenario: functional form = sine

```{r sine}
# --- Scenario: functional form
scenarios.func3 <- scenarios %>% filter(n==N & p==P & b1==10 & b2==10 & dg.thresh == "sine" & setting == "uni")
# scenarios.func3$eps.y[scenarios.func3$eps.y==1] <- 0.75
# scenarios.func3$eps.y[scenarios.func3$eps.y==2] <- 1.5
# scenarios.func3$eps.g[scenarios.func3$eps.g==1] <- 1
# scenarios.func3$eps.g[scenarios.func3$eps.g==2] <- 2
plan(multisession, workers=detectCores()*.75)
scenarios.func3$R2 <- future_sapply(1:nrow(scenarios.func3), function(x) compute_scnR2(data.frame(scenarios.func3[x,])), future.seed=TRUE)
scenarios.func3$R2 <- round(scenarios.func3$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func3)
```


# Setting: latent

* Sample size n = `r N`
* Nodes p = `r P`
* Results averaged over 10 runs
* Previous value of Noise(Y)=[0, 0.5, 1]
* Previous values of Noise(G)=[0, 0.05, 0.1] (but now Noise(G) added to $\eta_i$, so not comparable)


## Scenario: single threshold = 0.25
```{r single}
# --- Scenario: single threshold = 0.25
scenarios$R2 <- NA
scenarios.single <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & names(dg.thresh) == "single"  & setting == "latent")
scenarios.single$eps.y <- scenarios.single$eps.y *1.25
scenarios.single$eps.g <- scenarios.single$eps.g *1.25

plan(multisession, workers=detectCores()*.75)
scenarios.single$R2 <- future_sapply(1:nrow(scenarios.single), function(x) compute_scnR2(scenarios.single[x,]), future.seed=TRUE)
scenarios.single$R2 <- round(scenarios.single$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.single)
```


## Scenario: random threshold U(0.1,0.4)
```{r random}
# --- Scenario: random threshold U(0.1,0.4)
scenarios$R2 <- NA
scenarios.random <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & names(dg.thresh) == "random"  & setting == "latent")
scenarios.random$eps.y <- scenarios.random$eps.y *1.25
scenarios.random$eps.g <- scenarios.random$eps.g *1.25

plan(multisession, workers=detectCores()*.75)
scenarios.random$R2 <- future_sapply(1:nrow(scenarios.random), function(x) compute_scnR2(data.frame(scenarios.random[x,])), future.seed=TRUE)
scenarios.random$R2 <- round(scenarios.random$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.random)
```


## Scenario: functional form = flat
```{r flat}
# --- Scenario: functional form
scenarios.func1 <- scenarios %>% filter(n==N & b1==10 & is.na(b2) & p==P & dg.thresh == "flat" & setting == "latent")
scenarios.func1$eps.y <- scenarios.func1$eps.y *1.25
scenarios.func1$eps.g <- scenarios.func1$eps.g *1.25
plan(multisession, workers=detectCores()*.75)
scenarios.func1$R2 <- future_sapply(1:nrow(scenarios.func1), function(x) compute_scnR2(data.frame(scenarios.func1[x,])), future.seed=TRUE)
scenarios.func1$R2 <- round(scenarios.func1$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func1)
```

## Scenario: functional form = half-sine

```{r halfsine}
# --- Scenario: functional form
scenarios.func2 <- scenarios %>% filter(n==N & b1==10 & is.na(b2) & p==P & dg.thresh == "half-sine" & setting == "latent")
scenarios.func2$eps.y <- scenarios.func2$eps.y *1.25
scenarios.func2$eps.g <- scenarios.func2$eps.g *1.25
plan(multisession, workers=detectCores()*.75)
scenarios.func2$R2 <- future_sapply(1:nrow(scenarios.func2), function(x) compute_scnR2(data.frame(scenarios.func2[x,])), future.seed=TRUE)
scenarios.func2$R2 <- round(scenarios.func2$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func2)
```


## Scenario: functional form = sine

```{r sine}
# --- Scenario: functional form
scenarios.func3 <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & dg.thresh == "sine" & setting == "latent")
scenarios.func3$eps.y <- scenarios.func3$eps.y *1.25
scenarios.func3$eps.g <- scenarios.func3$eps.g *1.25
plan(multisession, workers=detectCores()*.75)
scenarios.func3$R2 <- future_sapply(1:nrow(scenarios.func3), function(x) compute_scnR2(data.frame(scenarios.func3[x,])), future.seed=TRUE)
scenarios.func3$R2 <- round(scenarios.func3$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func3)
```


# Setting: multi


## Scenario: single threshold = 0.25
```{r single}
# --- Scenario: single threshold = 0.25
scenarios$R2 <- NA
scenarios.single <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & names(dg.thresh) == "single"  & setting == "multi")
scenarios.single$eps.y <- scenarios.single$eps.y *1
scenarios.single$eps.g <- scenarios.single$eps.g *1

plan(multisession, workers=detectCores()*.75)
scenarios.single$R2 <- future_sapply(1:nrow(scenarios.single), function(x) compute_scnR2(scenarios.single[x,]), future.seed=TRUE)
scenarios.single$R2 <- round(scenarios.single$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.single)
```


## Scenario: random threshold U(0.1,0.4)
```{r random}
# --- Scenario: random threshold U(0.1,0.4)
scenarios$R2 <- NA
scenarios.random <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & names(dg.thresh) == "random"  & setting == "multi")
scenarios.random$eps.y <- scenarios.random$eps.y *1
scenarios.random$eps.g <- scenarios.random$eps.g *1

plan(multisession, workers=detectCores()*.75)
scenarios.random$R2 <- future_sapply(1:nrow(scenarios.random), function(x) compute_scnR2(data.frame(scenarios.random[x,])), future.seed=TRUE)
scenarios.random$R2 <- round(scenarios.random$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.random)
```


## Scenario: functional form = flat
```{r flat}
# --- Scenario: functional form
scenarios.func1 <- scenarios %>% filter(n==N & b1==10 & is.na(b2) & p==P & dg.thresh == "flat" & setting == "multi")
scenarios.func1$eps.y <- scenarios.func1$eps.y *0.75
scenarios.func1$eps.g <- scenarios.func1$eps.g *1
plan(multisession, workers=detectCores()*.75)
scenarios.func1$R2 <- future_sapply(1:nrow(scenarios.func1), function(x) compute_scnR2(data.frame(scenarios.func1[x,])), future.seed=TRUE)
scenarios.func1$R2 <- round(scenarios.func1$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func1)
```

## Scenario: functional form = half-sine

```{r halfsine}
# --- Scenario: functional form
scenarios.func2 <- scenarios %>% filter(n==N & b1==10 & is.na(b2) & p==P & dg.thresh == "half-sine" & setting == "multi")
scenarios.func2$eps.y <- scenarios.func2$eps.y *0.75
scenarios.func2$eps.g <- scenarios.func2$eps.g *1
plan(multisession, workers=detectCores()*.75)
scenarios.func2$R2 <- future_sapply(1:nrow(scenarios.func2), function(x) compute_scnR2(data.frame(scenarios.func2[x,])), future.seed=TRUE)
scenarios.func2$R2 <- round(scenarios.func2$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func2)
```


## Scenario: functional form = sine

```{r sine}
# --- Scenario: functional form
scenarios.func3 <- scenarios %>% filter(n==N & p==P & b1==10 & is.na(b2) & dg.thresh == "sine" & setting == "multi")
scenarios.func3$eps.y <- scenarios.func3$eps.y *1
scenarios.func3$eps.g <- scenarios.func3$eps.g *1
plan(multisession, workers=detectCores()*.75)
scenarios.func3$R2 <- future_sapply(1:nrow(scenarios.func3), function(x) compute_scnR2(data.frame(scenarios.func3[x,])), future.seed=TRUE)
scenarios.func3$R2 <- round(scenarios.func3$R2,2)
plan(sequential)
xtabs(R2~eps.y+eps.g, data = scenarios.func3)
```


